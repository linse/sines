<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      margin: 0px;
      overflow: hidden;
    }
  </style>
</head>
<body>
<div id="container"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r61/three.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
  uniform float time;
  uniform vec2 resolution;
  void main()  {
    gl_Position = vec4( position, 1.0 );
  }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
  uniform float time;
  uniform vec2 resolution;

  float PI = 3.1415;

  void red() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }

  vec4 gray(float rgb) {
    return vec4(rgb, rgb, rgb, 1.0);
  }

  vec4 gray_red(float rgb) {
    return vec4(rgb*rgb, rgb, rgb, 1.0);
  }

  vec4 color(float rgb) {
    return vec4(1.0-rgb, cos(rgb/8.0), rgb, 1.0);
  }

  // 100 is an absolute frequency
  // for freq relative to window width, do c.x * freq / resolution.x
  void stripes() {
    vec2 c = gl_FragCoord.xy;
    float rgb = mod(c.x, 20.0) < 10.0 ? 1.0 : 0.0;
    gl_FragColor = gray(rgb);
  }

  void x_sine() {
    vec2 c = gl_FragCoord.xy;
    float rgb = 0.5 + sin(2.0*PI*100.0*c.x)/2.0;
    gl_FragColor = gray(rgb);
  }

  void y_sine() {
    vec2 c = gl_FragCoord.xy;
    float rgb = 0.5 + sin(2.0*PI*100.0*c.y)/2.0;
    gl_FragColor = gray(rgb);
  }

  void xy_sine() {
    vec2 c = gl_FragCoord.xy;
    float rgb = 0.5 + sin(2.0*PI*100.0*c.x)/2.0
                    + sin(2.0*PI*100.0*c.y)/2.0;
    gl_FragColor = gray(rgb);
  }

  void xy_sine_hat() {
    vec2 c = gl_FragCoord.xy;
    float rgb = 0.5 + sin(2.0*PI*1.0*(c.x*c.x + c.y*c.y));
    gl_FragColor = gray(rgb);
  }

  void xy_sine_time_old() {
    vec2 c = gl_FragCoord.xy;
    float rgb = 0.5 + sin(time*0.02)/2.0 
                    + sin(2.0*PI*100.0*(c.x))/2.0
                    + sin(2.0*PI*100.0*c.y)/2.0;
    gl_FragColor = color(rgb);
  }

  float square(float x) {
    return x*x;
  }

  // moving ripple
  void xy_sine_time_moving_ripple() {
    vec2 c = gl_FragCoord.xy;
    float rgb = 0.5 + sin(time*0.02)/2.0 
                    + sin(2.0*PI*50.0*c.x+time*0.03)/2.0
                    + sin(2.0*PI*80.0*c.y+time*0.02)/2.0
                    + sin(2.0*PI*.5*(square(c.x-sin(time*0.02)/resolution.x*100.0) + square(c.y-sin(time*0.032)/resolution.x*100.0)));
    gl_FragColor = color(rgb);
  }

  // fuse and roll
  void xy_sine_time() {
    vec2 c = gl_FragCoord.xy / resolution.x;// * 2.0); for retina screen
    float time = 0.002 * time;
    float rgb = 0.5 + sin(time*0.02)/2.0 
                    + sin(2.0*PI*20.0*sqrt((square(sin(time)-c.x) + square(c.y))))
                    + sin(2.0*PI*20.0*sqrt((square(c.x) + square(sin(time)-c.y))));
    gl_FragColor = gray_red(rgb);
  }

  void xy_sine_hat_time() {
    vec2 c = gl_FragCoord.xy;
    float time = time * 0.005;
    float rgb = 0.5 + sin(time)/2.0 
                    + sin(2.0*PI*100.0*c.x)/2.0
                    + sin(2.0*PI*100.0*c.y)/2.0
                    + sin(2.0*PI*.5*(square(c.x-sin(time)/resolution.x*100.0) + square(c.y-sin(time)/resolution.x*100.0)));
    gl_FragColor = gray_red(rgb);
  }

  void xy_sine_hat_time2() {
    vec2 c = gl_FragCoord.xy;
    float time = time * 0.005;
    float rgb = 0.5 //+ sin(time)/2.0 
                    //+ sin(2.0*PI*100.0*c.x)/2.0
                    //+ sin(2.0*PI*100.0*c.y)/2.0
                    + sin(2.0*PI*.5*(square(c.x+sin(time)/resolution.x*.2) + 
                                     square(c.y+sin(time)/resolution.y*50.0)));
    gl_FragColor = color(rgb);
  }


  void main()  {
    xy_sine_time();

    //xy_sine_hat_time();
  }
</script>
<script>
  var container;
  var camera, scene, renderer;
  var uniforms, material, mesh;
  var mouseX = 0, mouseY = 0,
  lat = 0, lon = 0, phy = 0, theta = 0;
  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;
  init();
  var startTime = Date.now();
  animate();
  function init() {
    container = document.getElementById( 'container' );
    camera = new THREE.Camera();
    camera.position.z = 1;
    scene = new THREE.Scene();
    uniforms = {
      time: { type: "f", value: 1.0 },
      resolution: { type: "v2", value: new THREE.Vector2() }
    };
    material = new THREE.ShaderMaterial( {
      uniforms: uniforms,
      vertexShader: document.getElementById( 'vertexShader' ).textContent,
      fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    });
    mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), material );
    scene.add( mesh );
    renderer = new THREE.WebGLRenderer();
    container.appendChild( renderer.domElement );
    uniforms.resolution.value.x = window.innerWidth;
    uniforms.resolution.value.y = window.innerHeight;
    renderer.setSize( window.innerWidth, window.innerHeight );
  }
  function animate() {
    requestAnimationFrame( animate );
    render();
  }
  function render() {
    var elapsedMilliseconds = Date.now() - startTime;
    var elapsedSeconds = elapsedMilliseconds / 1000.;
    uniforms.time.value = 60. * elapsedSeconds;
    renderer.render( scene, camera );
  }

</script>
</body>
</html>
